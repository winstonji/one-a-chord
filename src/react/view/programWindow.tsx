import React, { useEffect, useState, createContext, useRef } from 'react'
import Toolbar from './globalComponents/toolbar';
import Canvas from './globalComponents/canvas';
import { Chart } from '../model/chart';
import { Key } from '../model/key';
import { ChartMetaData } from '../model/chartMetaData';
import { ChordWrapper } from '../model/chordWrapper';
import { ChartService } from '../services/chartService';
import { v4 as uuidv4 } from 'uuid';
import { Line } from '../model/line';
import { Block } from '../model/block';
import { generateFakeChart } from '../test/testUtils/chartFaker';

export interface FocusRef{
    id: string;
    position: number;
}

export type UpdateFocusRefVal = Partial<FocusRef>;

export interface ChartContextType {
    chart: Chart;
    chartService: ChartService;
    currentFocus: FocusRef;
    setCurrentFocus: (val: UpdateFocusRefVal) => void
}

export const ChartContext = createContext<ChartContextType>(null); 

const ProgramWindow = () => {

    const [chart, setChart] = useState<Chart | undefined>();
    const chartService = new ChartService(setChart);
    const [currentFocus, setCurrentFocus] = useState<FocusRef>();

    useEffect(() => {
        const initialChart: Chart = generateFakeChart().chart;

        //default to first chord wrapper in the chart.
         setCurrentFocus({
            id: initialChart.blocks[0].children[0].children[0].id,
            position: 0
        });
        setChart(initialChart);
    }, [])
    

    function currentFocusHelper(val: UpdateFocusRefVal){
        setCurrentFocus((currentFocus) => {
            return {
                id: val.id?? currentFocus.id,
                position: val.position?? currentFocus.position
            }
        })
    }

    const id = uuidv4();

	return (
        <>
        {chart && 
            <ChartContext.Provider value={{chart, chartService, currentFocus, setCurrentFocus: currentFocusHelper}}>
                {<>
                    <Toolbar/>
                    <Canvas/>
                </>}
                {/* You can remove this line if you don't need to debug if the chart state is updating */}
                <pre>{stringifyWithCircularForHTML(chart)}</pre>
            </ChartContext.Provider>
        }
        </>
    );
}

export default ProgramWindow;

//Generated by chatGPT to print the chart object with it's circular dependencies.
function stringifyWithCircularForHTML(obj) {
    const seen = new WeakSet();
    const jsonString = JSON.stringify(obj, function(key, value) {
        if (typeof value === 'object' && value !== null) {
            if (seen.has(value)) {
                return '[Circular Reference]';
            }
            seen.add(value);
        }
        return value;
    }, 2); // Add indentation for pretty printing

    return `${jsonString}`;
}
